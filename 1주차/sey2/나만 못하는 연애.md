# 나만 못하는 연애

 - 조건이 있는 MST를 구성하는 문제 
 - 크루스칼 알고리즘을 통해 MST를 구성하면서 같은 성별의 대학교이면 같은 집합을 구성하지 않고 건너띈다.
 - 위 조건을 만족하면서 MST를 구성하면 되는 단순 MST 문제 
 - 모든 학교를 연결하는 경로가 없을 경우 -1을 출력한다. 라는 조건이 있는데 이 문장은 MST를 구성하지 못하면 -1을 출력한다라고 이해하면 된다.
   (MST 트리의 간선이 N-1이 아니면 -1을 출력하면 된다.)

```kotlin
lateinit var parent: IntArray
lateinit var arr: ArrayList<Pair<Int, Boolean>>
lateinit var graph: ArrayList<Triple<Int, Int, Int>>

fun main() {
    val br = System.`in`.bufferedReader()
    val (n, m) = br.readLine().split(" ").map { it.toInt() }
    parent = IntArray(n+1) { it }
    graph = arrayListOf()

    arr = arrayListOf()
    val input = br.readLine().split(" ")

    arr.apply {
        add(Pair(0, false))
        repeat(n) {index ->
            arr.add(Pair(index + 1, input[index] == "M"))
        }
    }

    repeat(m) {
        val (a, b, c) = br.readLine().split(" ").map{ it.toInt() }
        graph.add(Triple(a, b, c))
    }

    graph.sortBy { it.third }

    kruskal(n)
}

fun kruskal(n: Int) {
    var cost = 0
    var cnt = 0

    for(i in 0 until graph.size) {
        val rootA = find(graph[i].first)
        val rootB = find(graph[i].second)

        if(rootA != rootB && arr[graph[i].first].second != arr[graph[i].second].second) {
            cnt ++
            cost += graph[i].third
            union(graph[i].first, graph[i].second)
        }
    }

    if(cnt < n-1) print("-1") else print(cost)
}

fun union(a: Int, b: Int) {
    val x = find(a)
    val y = find(b)

    if(x < y) parent[y] = x
    else parent[x] = y
}

fun find(x: Int): Int {
    return if(parent[x] == x) x
    else find(parent[x])
}

```